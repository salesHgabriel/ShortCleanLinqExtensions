using Microsoft.AspNetCore.Http;
using Microsoft.AspNetCore.WebUtilities;
using ShortCleanLinqExtensions.src.Utils.PaginatorHelper;
using System.Linq.Expressions;

namespace ShortCleanLinqExtensions.src.Extensions
{
    public static class AsQueryableExtension
    {
        /// <summary>
        /// The paginate method automatically takes care of setting the query's "limit" and "offset" based on the current page being viewed by the user.
        /// By default, the current page is detected by the value of the page query string argument on the HTTP request.
        /// This value is automatically detected by Laravel, and is also automatically inserted into links generated by the paginator.
        /// Case if you not to use HttpRequest and IHttpContextAccessor you won't create links as
        /// </summary>
        /// <typeparam name="T"></typeparam>
        /// <param name="items"></param>
        /// <param name="request"></param>
        /// <param name="httpContextAccessor"></param>
        /// <param name="page"></param>
        /// <param name="limit"></param>
        /// <returns>PagedResponse</returns>
        public static PagedResponse<List<T>> Paginate<T>(this IQueryable<T> items, int page = 1, int limit = 15, HttpRequest? request = null, IHttpContextAccessor? httpContextAccessor = null)
        {
            page = page <= 1 ? 1 : page;

            var total = items
                .ToList()
                .Count();

            var listPaginated = items
              .Skip((page - 1) * limit)
              .Take(limit);

            var respose = new PagedResponse<List<T>>(listPaginated.ToList(), page, limit);

            var totalPages = ((double)total / (double)limit);

            int roundedTotalPages = Convert.ToInt32(Math.Ceiling(totalPages));

            if (request is not null && httpContextAccessor is not null)
            {
                var route = request.Path.Value;

                string url = string.Concat(httpContextAccessor?.HttpContext?.Request.Scheme, "://", httpContextAccessor?.HttpContext?.Request.Host.ToUriComponent());

                // Uri uri = GetPageUri(page, limit, url, route);

                respose.NextPage =
                    page >= 1 && page < roundedTotalPages
                    ? GetPageUri(page + 1, limit, url, route)
                    : null;

                respose.PreviousPage =
                    page - 1 >= 1 && page <= roundedTotalPages
                    ? GetPageUri(page - 1, limit, url, route)
                    : null;

                respose.FirstPage = GetPageUri(1, limit, url, route);

                respose.LastPage = GetPageUri(roundedTotalPages, limit, url, route);
            }

            respose.Total = total;

            return respose;
        }

        /// <summary>
        /// The when method will execute the given callback when the first argument given to the method evaluates to true.
        /// </summary>
        /// <typeparam name="T"></typeparam>
        /// <param name="source"></param>
        /// <param name="conditional"></param>
        /// <param name="predicate"></param>
        /// <returns></returns>
        public static IQueryable<T> When<T>(this IQueryable<T> source, bool conditional, Expression<Func<T, bool>> predicate)
        {
            if (conditional)
            {
                return source.Where(predicate);
            }
            return source;
        }

        #region PRIVATE METHODS

        private static Uri GetPageUri(int page = 1, int limit = 15, string baseUri = "https://localhost/", string route = "/not-found")
        {
            var _enpointUri = new Uri(string.Concat(baseUri, route));
            var modifiedUri = QueryHelpers.AddQueryString(_enpointUri.ToString(), "page", page.ToString());
            modifiedUri = QueryHelpers.AddQueryString(modifiedUri, "limit", limit.ToString());
            return new Uri(modifiedUri);
        }

        #endregion PRIVATE METHODS
    }
}