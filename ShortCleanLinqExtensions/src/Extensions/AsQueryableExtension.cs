using Microsoft.AspNetCore.Http;
using Microsoft.AspNetCore.WebUtilities;
using Microsoft.EntityFrameworkCore;
using Microsoft.EntityFrameworkCore.Query;
using ShortCleanLinqExtensions.src.Utils.PaginatorHelper;
using System.Collections;
using System.Linq.Expressions;
using System.Reflection;

namespace ShortCleanLinqExtensions.src.Extensions
{
    public static class AsQueryableExtension
    {
        /// <summary>
        /// The paginate method automatically takes care of setting the query's "limit" and "offset" based on the current page being viewed by the user.
        /// By default, the current page is detected by the value of the page query string argument on the HTTP request.
        /// This value is automatically detected by Laravel, and is also automatically inserted into links generated by the paginator.
        /// Case if you not to use HttpRequest and IHttpContextAccessor you won't create links as
        /// </summary>
        /// <typeparam name="T"></typeparam>
        /// <param name="items"></param>
        /// <param name="request"></param>
        /// <param name="httpContextAccessor"></param>
        /// <param name="page"></param>
        /// <param name="limit"></param>
        /// <returns>PagedResponse</returns>
        public static PagedResponse<List<T>> Paginate<T>(this IQueryable<T> items, int page = 1, int limit = 15, HttpRequest? request = null, IHttpContextAccessor? httpContextAccessor = null)
        {
            page = page <= 1 ? 1 : page;

            limit = limit is > 100 or <= 0 ? 100 : limit;

            var total = items
                .ToList()
                .Count();

            var listPaginated = items
              .Skip((page - 1) * limit)
              .Take(limit);

            var respose = new PagedResponse<List<T>>(listPaginated.ToList(), page, limit);

            var totalPages = ((double)total / (double)limit);

            int roundedTotalPages = Convert.ToInt32(Math.Ceiling(totalPages));

            if (request is not null && httpContextAccessor is not null)
            {
                var route = request.Path.Value!;

                string url = string.Concat(httpContextAccessor?.HttpContext?.Request.Scheme, "://", httpContextAccessor?.HttpContext?.Request.Host.ToUriComponent());

                // Uri uri = GetPageUri(page, limit, url, route);

                respose.NextPage =
                    page >= 1 && page < roundedTotalPages
                    ? GetPageUri(page + 1, limit, url, route)
                    : null;

                respose.PreviousPage =
                    page - 1 >= 1 && page <= roundedTotalPages
                    ? GetPageUri(page - 1, limit, url, route)
                    : null;

                respose.FirstPage = GetPageUri(1, limit, url, route);

                respose.LastPage = GetPageUri(roundedTotalPages, limit, url, route);
            }

            respose.Total = total;

            return respose;
        }

        public static async Task<PagedResponse<List<T>>> PaginateAsync<T>(this IQueryable<T> items, int page = 1, int limit = 15, HttpRequest? request = null, IHttpContextAccessor? httpContextAccessor = null)
        {
            page = page <= 1 ? 1 : page;

            limit = limit is > 100 or <= 0 ? 100 : limit;

            var total = await items
                .CountAsync();

            var listPaginated = items
              .Skip((page - 1) * limit)
              .Take(limit);

            var respose = new PagedResponse<List<T>>(await listPaginated.ToListAsync(), page, limit);

            var totalPages = ((double)total / (double)limit);

            int roundedTotalPages = Convert.ToInt32(Math.Ceiling(totalPages));

            if (request is not null && httpContextAccessor is not null)
            {
                var route = request.Path.Value!;

                string url = string.Concat(httpContextAccessor?.HttpContext?.Request.Scheme, "://", httpContextAccessor?.HttpContext?.Request.Host.ToUriComponent());

                respose.NextPage =
                    page >= 1 && page < roundedTotalPages
                    ? GetPageUri(page + 1, limit, url, route)
                    : null;

                respose.PreviousPage =
                    page - 1 >= 1 && page <= roundedTotalPages
                    ? GetPageUri(page - 1, limit, url, route)
                    : null;

                respose.FirstPage = GetPageUri(1, limit, url, route);

                respose.LastPage = GetPageUri(roundedTotalPages, limit, url, route);
            }

            respose.Total = total;

            return respose;
        }


        /// <summary>
        /// The when method will execute the given callback when the first argument given to the method evaluates to true.
        /// </summary>
        /// <typeparam name="T"></typeparam>
        /// <param name="source"></param>
        /// <param name="conditional"></param>
        /// <param name="predicate"></param>
        /// <returns></returns>
        public static IQueryable<T> When<T>(this IQueryable<T> source, bool conditional, Expression<Func<T, bool>> predicate)
        {
            if (conditional)
            {
                return source.Where(predicate);
            }
            return source;
        }

        /// <summary>
        /// The when method will execute the given callback when the first argument given to the method evaluates to true and include navigation query.
        /// </summary>
        /// <typeparam name="T"></typeparam>
        /// <typeparam name="P"></typeparam>
        /// <param name="source"></param>
        /// <param name="conditional"></param>
        /// <param name="navigationPropertyPath"></param>
        /// <returns></returns>
        public static IQueryable<T> WhenInclude<T, P>(this IQueryable<T> source, bool conditional, Expression<Func<T, P>> navigationPropertyPath)
        {
            if (conditional)
            {
                return source.Provider.CreateQuery<T>(
                             Expression.Call(
                                 instance: null,
                                 method: IncludeMethodInfo.MakeGenericMethod(typeof(T), typeof(P)),
                                 arguments: [source.Expression, Expression.Quote(navigationPropertyPath)]));
            }
            return source;
        }

        #region PRIVATE METHODS

        private static Uri GetPageUri(int page = 1, int limit = 15, string baseUri = "https://localhost/", string route = "/not-found")
        {
            var _enpointUri = new Uri(string.Concat(baseUri, route));
            var modifiedUri = QueryHelpers.AddQueryString(_enpointUri.ToString(), "page", page.ToString());
            modifiedUri = QueryHelpers.AddQueryString(modifiedUri, "limit", limit.ToString());
            return new Uri(modifiedUri);
        }

        private sealed class IncludableQueryable<TEntity, TProperty> : IIncludableQueryable<TEntity, TProperty>, IAsyncEnumerable<TEntity>
        {
            private readonly IQueryable<TEntity> _queryable;

            public IncludableQueryable(IQueryable<TEntity> queryable)
            {
                _queryable = queryable;
            }

            public Expression Expression
                => _queryable.Expression;

            public Type ElementType
                => _queryable.ElementType;

            public IQueryProvider Provider
                => _queryable.Provider;

            public IAsyncEnumerator<TEntity> GetAsyncEnumerator(CancellationToken cancellationToken = default)
                => ((IAsyncEnumerable<TEntity>)_queryable).GetAsyncEnumerator(cancellationToken);

            public IEnumerator<TEntity> GetEnumerator()
                => _queryable.GetEnumerator();

            IEnumerator IEnumerable.GetEnumerator()
                => GetEnumerator();
        }

        internal static readonly MethodInfo IncludeMethodInfo
        = typeof(EntityFrameworkQueryableExtensions)
           .GetTypeInfo().GetDeclaredMethods(nameof(WhenInclude))
           .Single(
               mi =>
                   mi.GetGenericArguments().Length == 2
                   && mi.GetParameters().Any(
                       pi => pi.Name == "navigationPropertyPath" && pi.ParameterType != typeof(string)));

        #endregion PRIVATE METHODS
    }
}